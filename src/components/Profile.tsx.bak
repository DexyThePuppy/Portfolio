import React, { useState, useRef, useEffect } from 'react';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { 
  faTwitter, 
  faLastfm,
  faBluesky,
  faInstagram,
  faTelegram,
  faDiscord,
  faSteam,
  faPlaystation,
  faWindows,
  faApple
} from '@fortawesome/free-brands-svg-icons';
import { 
  faGamepad,
  faDesktop,
  faTablet,
  faVrCardboard,
  faMemory,
  faComputer,
  faLaptop,
  faDisplay,
  faGhost
} from '@fortawesome/free-solid-svg-icons';
import { 
  MapPinIcon, 
  UserIcon, 
  StarIcon,
  HomeIcon,
  MagnifyingGlassIcon,
  UserGroupIcon,
  CalendarIcon,
  ChatBubbleLeftIcon,
  CheckBadgeIcon,
  XMarkIcon,
  GlobeAltIcon,
  HeartIcon,
  ShieldCheckIcon,
  UserCircleIcon,
  ChatBubbleOvalLeftIcon,
  RocketLaunchIcon,
  LanguageIcon,
  LockClosedIcon,
  ComputerDesktopIcon,
  DeviceTabletIcon,
  CubeIcon,
  FilmIcon,
  MusicalNoteIcon,
  PhotoIcon,
  HeartIcon as HeartIconSolid,
  HandRaisedIcon,
  FaceSmileIcon,
  CloudIcon,
  WrenchScrewdriverIcon,
  PaperAirplaneIcon,
  CakeIcon,
  ArrowTopRightOnSquareIcon,
} from '@heroicons/react/24/outline';

interface UploadedImage {
  uuid: string;
  contentRating: string;
  width: number;
  height: number;
  blurHash: string;
}

interface ProfileImage {
  id: string;
  image: UploadedImage;
  accessPermission: string;
  isAd: boolean;
}

interface Place {
  place: string;
  region: string;
  country: string;
  countryCode: string;
  longitude: number;
  latitude: number;
}

interface ProfileLocation {
  type: string;
  homePlace: Place;
  place: Place;
}

interface SocialAccount {
  id: string;
  socialNetwork: string;
  isVerified: boolean;
  url: string;
  displayName: string;
  value: string;
  accessPermission: string;
}

interface Species {
  id: string;
  displayName: string;
}

interface Sona {
  id: string;
  displayName: string;
  hasFursuit: boolean;
  species: Species;
  images: ProfileImage[];
}

interface SocialPreference {
  id: string;
  title: string;
  icon: React.ElementType;
}

interface JoinedGroup {
  id: string;
  name: string;
  icon: string;
}

interface ProfileProps {
  profile: {
    id: string;
    uuid: string;
    displayName: string;
    username: string;
    roles: string[];
    age: number;
    dateOfBirth: string;
    profileImage: ProfileImage;
    location: ProfileLocation;
    images: ProfileImage[];
    bio: {
      biography: string;
      genders: string[];
      languages: string[];
      relationshipStatus: string;
    };
    socialAccounts: SocialAccount[];
    sonas: Sona[];
    socialPreferences?: SocialPreference[];
    joinedGroups?: JoinedGroup[];
  };
}

// Register the global window properties for TypeScript
declare global {
  interface Window {
    forceImageReload?: number;
    bypassImageCache?: boolean;
  }
}

const getImageUrl = (uuid: string, width: number = 374) => {
  return `https://assets.barq.app/image/${uuid}.jpeg?width=${width}`;
};

const Profile: React.FC<ProfileProps> = ({
  profile
}) => {
  const isVip = profile.roles.includes('supporter_vip');
  const publicSocialAccounts = profile.socialAccounts.filter(account => account.accessPermission === 'public');
  const publicImages = profile.images.filter(img => img.accessPermission === 'public' && !img.isAd);
  
  // Create an extended array of images for infinite scroll
  const shuffleArray = (array: any[]) => {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  };

  // Create an array that's 5 times longer than the original, with shuffled duplicates
  const createExtendedImages = () => {
    const multiplier = 5;
    const extended = [];
    for (let i = 0; i < multiplier; i++) {
      extended.push(...shuffleArray(publicImages));
    }
    return extended;
  };

  const [extendedImages, setExtendedImages] = useState(createExtendedImages());
  const [selectedImage, setSelectedImage] = useState<ProfileImage | null>(null);
  const [currentIndex, setCurrentIndex] = useState(Math.floor(publicImages.length * 2)); // Start in the middle
  const [isAnimating, setIsAnimating] = useState(false);
  const [startPosition, setStartPosition] = useState<{ 
    x: number; 
    y: number; 
    width: number; 
    height: number;
    centerX?: number;
    centerY?: number;
  } | null>(null);
  const [showHighRes, setShowHighRes] = useState(false);
  const imageRefs = useRef<{ [key: string]: HTMLDivElement | null }>({});
  const thumbnailUrl = useRef<string>('');
  const isModalOpen = useRef(false);
  const carouselContainerRef = useRef<HTMLDivElement>(null);
  const [itemWidth, setItemWidth] = useState(0);
  const [scrollY, setScrollY] = useState(0);
  const [naturalDimensions, setNaturalDimensions] = useState<{width: number; height: number} | null>(null);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [loadingProgress, setLoadingProgress] = useState(0);
  const [showLoadingBar, setShowLoadingBar] = useState(false);
  const [springAnimation, setSpringAnimation] = useState(false);
  const [imageCacheBuster, setImageCacheBuster] = useState<number | null>(null);
  const progressIntervalRef = useRef<number | null>(null);
  // Track gallery refresh state
  const [galleryKey, setGalleryKey] = useState(0);

  // Keep track of already loaded images and their dimensions
  const loadedImages = useRef<{[key: string]: { src: string, width: number, height: number, isFullRes: boolean }}>({});
  
  // Track high-res loaded status
  const fullResLoadedImages = useRef<Set<string>>(new Set());

  // Main Info - Updated to match bio exactly
  const mainInfo = [
    { id: '1', title: 'Main', icon: UserIcon },
    { id: '2', title: '22 | Austria & Germany', icon: MapPinIcon },
    { id: '3', title: 'He/Him', icon: UserIcon },
    { id: '4', title: 'Australian Shep & Bernese Mountain Dog-dragon hybrid mix', icon: UserIcon },
    { id: '5', title: 'Gay Derg Doggo', icon: HeartIcon },
    { id: '6', title: 'Ambivert', icon: UserGroupIcon }
  ];

  // Stats - Updated to match bio exactly
  const statsInfo = [
    { 
      category: 'Physical',
      items: [
        { id: '1', title: 'Height 187cm/6.13feet', icon: UserIcon },
        { id: '2', title: 'Weight 99kg/218,3lbs', icon: HeartIcon }
      ]
    },
    {
      category: 'Traits',
      items: [
        { id: '1', title: 'Absolutely Adorable', icon: FaceSmileIcon },
        { id: '2', title: 'Cuddle Buddy', icon: HeartIconSolid }
      ]
    },
    {
      category: 'Personality',
      items: [
        { id: '1', title: 'Overwhelmed fast', icon: HandRaisedIcon },
        { id: '2', title: 'Emotionally Sensitive', icon: HeartIcon },
        { id: '3', title: 'Pretty shy', icon: FaceSmileIcon },
        { id: '4', title: 'Smol Spoon', icon: HeartIconSolid },
        { id: '5', title: 'Very jealous', icon: HeartIcon }
      ]
    }
  ];

  // Personality Traits
  const personalityTraits = [
    { id: '1', title: 'Absolutely Adorable', icon: FaceSmileIcon },
    { id: '2', title: 'Cuddle Buddy', icon: HeartIconSolid },
    { id: '3', title: 'Overwhelmed fast', icon: HandRaisedIcon },
    { id: '4', title: 'Emotionally Sensitive', icon: HeartIcon },
    { id: '5', title: 'Pretty shy', icon: FaceSmileIcon },
    { id: '6', title: 'Smol Spoon', icon: HeartIconSolid },
    { id: '7', title: 'Very jealous', icon: HeartIcon }
  ];

  // Professional Skills
  const professionalSkills = [
    { id: '1', title: 'Front-end Dev', icon: CloudIcon },
    { id: '2', title: '3D Artist', icon: CubeIcon },
    { id: '3', title: 'Future Content Creator', icon: FilmIcon },
    { id: '4', title: 'Music Producer', icon: MusicalNoteIcon }
  ];

  // Hobbies
  const hobbies = [
    { id: '1', title: 'Jailbreaking Devices', icon: WrenchScrewdriverIcon },
    { id: '2', title: 'Social Media', icon: PhotoIcon },
    { id: '3', title: 'PC/VR Gaming', icon: ComputerDesktopIcon }
  ];

  // Languages with flags
  const languages = [
    { id: '1', name: 'Austrian', flag: 'ðŸ‡¦ðŸ‡¹' },
    { id: '2', name: 'German', flag: 'ðŸ‡©ðŸ‡ª' },
    { id: '3', name: 'American', flag: 'ðŸ‡ºðŸ‡¸' },
    { id: '4', name: 'Bosnian', flag: 'ðŸ‡§ðŸ‡¦' }
  ];

  // Tech Setup
  const techSetup = {
    gaming: [
      { id: '1', title: 'PC: Ryzen 9 7950x3D & RTX 4090', icon: ComputerDesktopIcon },
      { id: '2', title: 'VR: Quest 2, 4x Trackers & 2x Basestation', icon: DeviceTabletIcon }
    ],
    computers: [
      { id: '1', title: 'Laptop: Macbook M1 Pro 14', icon: ComputerDesktopIcon }
    ]
  };

  // Platforms
  const platforms = [
    { id: '1', title: 'Resonite', icon: faVrCardboard },
    { id: '2', title: 'VRChat', icon: faVrCardboard },
    { id: '3', title: 'Second Life', icon: faDesktop }
  ];

  // Calculate the number of visible items based on screen width
  const getVisibleItems = (width: number) => {
    if (width <= 640) return 3;
    if (width <= 768) return 4;
    if (width <= 1024) return 5;
    if (width <= 1280) return 6;
    return 7;
  };

  // Calculate item width based on container width
  const calculateItemWidth = () => {
    if (!carouselContainerRef.current) return;
    const containerWidth = carouselContainerRef.current.clientWidth;
    const visibleItems = getVisibleItems(window.innerWidth);
    const gap = 8; // 0.5rem gap
    const totalGaps = visibleItems - 1;
    const availableWidth = containerWidth - (totalGaps * gap);
    const calculatedItemWidth = Math.floor(availableWidth / visibleItems);
    setItemWidth(calculatedItemWidth);
  };

  const visibleItems = getVisibleItems(window.innerWidth);

  useEffect(() => {
    calculateItemWidth();
    const handleResize = () => {
      calculateItemWidth();
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const handleNext = () => {
    if (isAnimating) return;
    setIsAnimating(true);
    
    // If we're near the end, reset to the middle while maintaining visual position
    if (currentIndex >= extendedImages.length - visibleItems - 5) {
      const newImages = createExtendedImages();
      setExtendedImages(newImages);
      setCurrentIndex(Math.floor(publicImages.length * 2));
    } else {
      setCurrentIndex(prev => prev + 1);
    }
    
    setTimeout(() => setIsAnimating(false), 500);
  };

  const handlePrev = () => {
    if (isAnimating) return;
    setIsAnimating(true);
    
    // If we're near the start, reset to the middle while maintaining visual position
    if (currentIndex <= 5) {
      const newImages = createExtendedImages();
      setExtendedImages(newImages);
      setCurrentIndex(Math.floor(publicImages.length * 2));
    } else {
      setCurrentIndex(prev => prev - 1);
    }
    
    setTimeout(() => setIsAnimating(false), 500);
  };

  useEffect(() => {
    const interval = setInterval(() => {
      if (!isAnimating) {
        handleNext();
      }
    }, 5000);
    return () => clearInterval(interval);
  }, [currentIndex, isAnimating]);

  // Handle parallax effect with smoothing for ease in/out
  useEffect(() => {
    let ticking = false;
    let lastScrollY = 0;
    let currentY = 0;
    
    const handleScroll = () => {
      // Only track scroll when modal is not open
      if (isModalOpen.current) return;
      
      lastScrollY = window.scrollY;
      
      if (!ticking) {
        window.requestAnimationFrame(() => {
          // Smooth interpolation toward target value
          currentY = currentY + (lastScrollY - currentY) * 0.075;
          setScrollY(currentY);
          ticking = false;
        });
        
        ticking = true;
      }
    };
    
    // Set up an animation loop for smoother transitions
    const animate = () => {
      // Skip animation when modal is open
      if (isModalOpen.current) return;
      
      if (Math.abs(lastScrollY - currentY) > 0.1) {
        currentY = currentY + (lastScrollY - currentY) * 0.075;
        setScrollY(currentY);
      }
      requestAnimationFrame(animate);
    };
    
    const animationId = requestAnimationFrame(animate);
    window.addEventListener('scroll', handleScroll, { passive: true });
    
    return () => {
      window.removeEventListener('scroll', handleScroll);
      cancelAnimationFrame(animationId);
    };
  }, []);

  useEffect(() => {
    if (selectedImage) {
      // Mark modal as open to prevent parallax scroll handling
      isModalOpen.current = true;
      
      // Just disable scrolling when modal is open, without affecting position
      document.body.style.overflow = 'hidden';
    } else {
      // Re-enable scrolling when modal is closed
      document.body.style.overflow = '';
      
      // Re-enable parallax effect after a short delay
      setTimeout(() => {
        isModalOpen.current = false;
      }, 100);
    }
  }, [selectedImage]);

  const calculateExpandedDimensions = () => {
    if (!startPosition) return null;
    
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    // Increase padding to make images smaller
    const padding = Math.min(50, Math.max(30, viewportWidth * 0.05)); // Larger padding
    
    // Calculate maximum available space - use more of the viewport
    const maxWidth = viewportWidth - (padding * 2);
    const maxHeight = viewportHeight - (padding * 2);
    
    // Determine target dimensions based on natural image size if available
    let targetWidth, targetHeight;
    
    if (naturalDimensions && naturalDimensions.width > 0 && naturalDimensions.height > 0) {
      console.log('Using natural dimensions for expanded view:', naturalDimensions);
      // Use natural dimensions but constrain to viewport
      const imageRatio = naturalDimensions.width / naturalDimensions.height;
      
      // Reduce fill factor to make images smaller
      const fillFactor = 0.85; // Reduced from 0.98 to 0.85
      
      if (imageRatio > maxWidth / maxHeight) {
        // Width constrained
        targetWidth = maxWidth * fillFactor;
        targetHeight = targetWidth / imageRatio;
    } else {
        // Height constrained
        targetHeight = maxHeight * fillFactor;
        targetWidth = targetHeight * imageRatio;
      }
    } else {
      console.log('No natural dimensions available, using fallback ratio');
      // Fallback if natural dimensions aren't available yet
      const defaultRatio = startPosition.width / startPosition.height;
      // Use less of the viewport space
      targetWidth = maxWidth * 0.85; // Reduced from 0.95 to 0.85
      targetHeight = targetWidth / defaultRatio;
      
      if (targetHeight > maxHeight) {
        targetHeight = maxHeight * 0.85; // Reduced from 0.95 to 0.85
        targetWidth = targetHeight * defaultRatio;
    }
    }
    
    // Calculate center position
    const centerX = viewportWidth / 2 - targetWidth / 2;
    const centerY = viewportHeight / 2 - targetHeight / 2;
    
    const result = {
      width: targetWidth,
      height: targetHeight,
      x: centerX,
      y: centerY
    };
    
    console.log('Calculated expanded dimensions:', result);
    return result;
  };

  // Preload gallery images on mount to have them in cache
  useEffect(() => {
    // Preload all gallery images at their intended sizes
    publicImages.forEach((photo, index) => {
      // Get size appropriate for this image
      const optimalSize = getGalleryImageSize(index);
      const url = getModifiedImageUrl(photo.image.uuid, optimalSize);
      
      // Set up preload and tracking
      const img = new Image();
      img.onload = () => {
        // Save natural dimensions for later use
        loadedImages.current[photo.image.uuid] = {
          src: url,
          width: img.naturalWidth,
          height: img.naturalHeight,
          isFullRes: img.naturalWidth >= 1200 || optimalSize >= 1200 // Consider high-res if width >= 1200px
        };
        
        // If this is a high-res image, mark it as full res loaded
        if (img.naturalWidth >= 1200 || optimalSize >= 1200) {
          fullResLoadedImages.current.add(photo.image.uuid);
        }
      };
      img.src = url;
    });
  }, [publicImages, imageCacheBuster]);

  // Modified handleImageClick to avoid reload and reuse loaded image
  const handleImageClick = (image: ProfileImage, index: number) => {
    console.log('Image clicked:', image.id, 'Index:', index);
    
    const imageElement = imageRefs.current[`image-${index}`];
    if (imageElement) {
      const rect = imageElement.getBoundingClientRect();
      console.log('Image element rect:', rect);
      
      // Check if element has the loaded class
      const isElementMarkedAsLoaded = imageElement.classList.contains('thumbnail-loaded');
      
      // More reliable check for whether full-res is loaded
      const isFullResAlreadyLoaded = (isElementMarkedAsLoaded || 
        (fullResLoadedImages.current.has(image.image.uuid) && 
         loadedImages.current[image.image.uuid]?.isFullRes === true));
      
      console.log('Is full-res already loaded:', isFullResAlreadyLoaded);
      
      // Cache info - crucial for proper dimension calculation
      const cachedImg = loadedImages.current[image.image.uuid];
      console.log('Cached image info:', cachedImg);
      
      // Get the exact URL of the image element - which is already loaded in DOM
      const imgElement = imageElement.querySelector('img');
      let currentSrc = '';
      let imgWidth = 0;
      let imgHeight = 0;
      if (imgElement) {
        // Use the actual image source that's already loaded
        currentSrc = imgElement.currentSrc || imgElement.src;
        imgWidth = imgElement.naturalWidth || 0;
        imgHeight = imgElement.naturalHeight || 0;
        console.log('Current source from DOM:', currentSrc);
        console.log('Image natural dimensions from DOM:', imgWidth, imgHeight);
      }
      
      // IMPORTANT: For cached images, always set dimensions immediately
      if (isFullResAlreadyLoaded && cachedImg?.isFullRes) {
        console.log('Using cached dimensions for full-res image:', cachedImg.width, cachedImg.height);
        setNaturalDimensions({
          width: cachedImg.width,
          height: cachedImg.height
        });
      } else if (isFullResAlreadyLoaded && imgWidth > 500 && imgHeight > 500) {
        // If the DOM image is large enough, use its dimensions as fallback
        console.log('Using DOM image dimensions:', imgWidth, imgHeight);
        setNaturalDimensions({
          width: imgWidth,
          height: imgHeight
        });
      } else {
        // For non-cached images, start with empty dimensions - will be updated later
        console.log('No cached dimensions available, will load from high-res');
        // Set approximate dimensions based on container to avoid jumps
        const viewportWidth = window.innerWidth * 0.8;
        const viewportHeight = window.innerHeight * 0.8;
        const aspectRatio = rect.width / rect.height;
        
        let estimatedWidth, estimatedHeight;
        if (aspectRatio > viewportWidth / viewportHeight) {
          estimatedWidth = viewportWidth;
          estimatedHeight = viewportWidth / aspectRatio;
        } else {
          estimatedHeight = viewportHeight;
          estimatedWidth = viewportHeight * aspectRatio;
        }
        
        setNaturalDimensions({
          width: estimatedWidth,
          height: estimatedHeight
        });
      }
      
      // Skip loading indicators if full-res is already loaded
      setImageLoaded(isFullResAlreadyLoaded);
      setLoadingProgress(isFullResAlreadyLoaded ? 100 : 5);
      setShowLoadingBar(!isFullResAlreadyLoaded);
      setSpringAnimation(false);
      
      // Clear any existing intervals
      if (progressIntervalRef.current) {
        clearInterval(progressIntervalRef.current);
        progressIntervalRef.current = null;
      }
      
      // Set thumbnail URL to the already loaded image - avoid redownloading
      thumbnailUrl.current = currentSrc || getModifiedImageUrl(image.image.uuid, getGalleryImageSize(index));
      
      // Store position and size of the clicked element
      setStartPosition({
        x: rect.left,
        y: rect.top,
        width: rect.width,
        height: rect.height,
        centerX: rect.left + (rect.width / 2),
        centerY: rect.top + (rect.height / 2)
      });
      
      // Set selected image
      setSelectedImage(image);
      
      // Set showHighRes based on whether we already have the full-res image
      setShowHighRes(isFullResAlreadyLoaded);
      
      // Start animation immediately after a short delay
      setTimeout(() => {
        console.log('Starting animation with dimensions:', naturalDimensions);
        setIsAnimating(true);
        
        // If full-res is already loaded, skip loading sequence
        if (isFullResAlreadyLoaded) {
          console.log('Full-res already loaded, skipping loading sequence');
          
          // Make sure we have proper dimensions for cached images
          if (!naturalDimensions || (!naturalDimensions.width && !naturalDimensions.height)) {
            // Immediately force load the high-res just to get dimensions
            const tempImg = new Image();
            tempImg.onload = () => {
              console.log('Loaded dimensions from temp image:', tempImg.naturalWidth, tempImg.naturalHeight);
              setNaturalDimensions({
                width: tempImg.naturalWidth,
                height: tempImg.naturalHeight
              });
              
              // Update cache
              loadedImages.current[image.image.uuid] = {
                src: tempImg.src,
                width: tempImg.naturalWidth,
                height: tempImg.naturalHeight,
                isFullRes: true
              };
              
              // Trigger spring animation after dimensions update
        setTimeout(() => {
                setSpringAnimation(true);
              }, 100);
            };
            tempImg.src = getModifiedImageUrl(image.image.uuid, 1500);
          } else {
            // Trigger spring animation after a short delay
            setTimeout(() => {
              setSpringAnimation(true);
        }, 300);
          }
          return; // Skip the loading sequence
        }

        // Rest of the loading sequence for non-cached images...

        // Always fetch high-res image for proper scaling, unless we're sure it's already cached
        if (!isFullResAlreadyLoaded) {
          const highResUrl = getModifiedImageUrl(image.image.uuid, 1500);
          console.log('Will load high-res from:', highResUrl);
          
          // Force getting dimensions from high-res image
          const highResImage = new Image();
          
          // Handle high-res image load completion
          highResImage.onload = () => {
            console.log('High-res image loaded with dimensions:', highResImage.naturalWidth, highResImage.naturalHeight);
            
            // Save in cache for future use
            loadedImages.current[image.image.uuid] = {
              src: highResImage.src,
              width: highResImage.naturalWidth,
              height: highResImage.naturalHeight,
              isFullRes: true
            };
            
            // Mark as full-res loaded
            fullResLoadedImages.current.add(image.image.uuid);
            
            // Update dimensions with high-res information
            setNaturalDimensions({
              width: highResImage.naturalWidth,
              height: highResImage.naturalHeight
            });
            
            // Stop progress simulation if still running
            if (progressIntervalRef.current) {
              clearInterval(progressIntervalRef.current);
              progressIntervalRef.current = null;
            }
            
            // Complete the loading sequence
            setLoadingProgress(100);
            
            setTimeout(() => {
              setImageLoaded(true);
              setShowHighRes(true);
              
              // Trigger spring animation
              setTimeout(() => {
                setSpringAnimation(true);
              }, 200);
              
              // Hide loading bar after a delay
              setTimeout(() => {
                setShowLoadingBar(false);
              }, 700);
            }, 300);
          };
          
          // Handle loading errors
          highResImage.onerror = () => {
            console.error('Failed to load high-res image:', highResUrl);
            
            // Stop progress simulation
            if (progressIntervalRef.current) {
              clearInterval(progressIntervalRef.current);
              progressIntervalRef.current = null;
            }
            
            // Complete loading anyway and use thumbnail
            setLoadingProgress(100);
            setTimeout(() => {
              setImageLoaded(true);
              setShowHighRes(true); // We'll show the thumbnail instead
              setSpringAnimation(true);
              setTimeout(() => {
                setShowLoadingBar(false);
              }, 700);
            }, 300);
          };
          
          // Start loading the high-res version 
          highResImage.src = highResUrl;
        }
      }, 50);
    }
  };

  // When high-res image is loaded
  const handleHighResImageLoad = () => {
    setImageLoaded(true);
    
    // Trigger spring animation after a short delay
    setTimeout(() => {
      setSpringAnimation(true);
    }, 50);
  };

  const handleClosePreview = (e?: React.MouseEvent) => {
    // Prevent click event from propagating if it's from the close button
    if (e) {
      e.stopPropagation();
    }
    
    // Clear any running interval
    if (progressIntervalRef.current) {
      clearInterval(progressIntervalRef.current);
      progressIntervalRef.current = null;
    }
    
    // First hide loading elements immediately - including children elements
    setShowLoadingBar(false);
    
    // Use a specific "closing" animation class
    setIsAnimating(false);
    setShowHighRes(false);
    setImageLoaded(false);
    setSpringAnimation(false);
    
    // Use a shorter timeout to match faster animation
    setTimeout(() => {
      setSelectedImage(null);
      setStartPosition(null);
      setNaturalDimensions(null);
      setLoadingProgress(0);
    }, 250); // Reduced from 400ms to 250ms for faster closing
  };

  // Function to clear cache for debugging
  const clearCache = () => {
    // Clear all image-related state
    setExtendedImages(createExtendedImages());
    setSelectedImage(null);
    setCurrentIndex(Math.floor(publicImages.length * 2));
    setIsAnimating(false);
    setStartPosition(null);
    setShowHighRes(false);
    setNaturalDimensions(null);
    setImageLoaded(false);
    
    // Clear URL cache
    thumbnailUrl.current = '';
    
    // Reset image refs
    imageRefs.current = {};
    
    // Clear loaded images tracking
    loadedImages.current = {};
    fullResLoadedImages.current.clear();
    
    // Clear "loaded" class from all thumbnails
    document.querySelectorAll('.thumbnail-loaded').forEach(element => {
      element.classList.remove('thumbnail-loaded');
    });
    
    // Force re-render carousel
    calculateItemWidth();
    
    // More aggressive cache clearing approach
    try {
      // Clear browser cache for images
      if ('caches' in window) {
        caches.keys().then(cacheNames => {
          cacheNames.forEach(cacheName => {
            caches.delete(cacheName);
          });
        });
      }
      
      // Add timestamp query parameter to image URLs to bypass cache
      const timestamp = Date.now();
      
      // Force refresh of all images by updating the cache buster timestamp
      setImageCacheBuster(timestamp);
      
      // Force re-mount of the gallery by changing its key
      setGalleryKey(prevKey => prevKey + 1);
      
      // Try to invalidate browser cache for specific images
      const urls = publicImages.map(img => getModifiedImageUrl(img.image.uuid));
      // Add profile image
      urls.push(getModifiedImageUrl(profile.profileImage.image.uuid));
      
      // Try to evict these URLs from memory cache
      urls.forEach(url => {
        // Create a dummy fetch to invalidate the cache
        fetch(url, { cache: 'reload', mode: 'no-cors' }).catch(() => {
          // Ignore errors - this is just an attempt to refresh the cache
        });
      });
      
      // Log for debugging
      console.log('Cache cleared, forcing image reload', timestamp);
      
      // Alert user
      alert('Cache cleared successfully. Images should refresh.');
    } catch (err) {
      console.error('Error clearing cache:', err);
      alert('Error clearing cache. Try refreshing the page.');
    }
  };

  // Calculate optimal image dimensions based on viewport and container
  const calculateOptimalImageSize = (containerWidth: number, devicePixelRatio = window.devicePixelRatio || 1): number => {
    // Round to nearest 50px increment for better CDN caching
    const size = Math.round((containerWidth * devicePixelRatio) / 50) * 50;
    // Set bounds (200px-800px) to prevent too small or too large requests
    return Math.max(200, Math.min(800, size));
  };

  // Improved getModifiedImageUrl to handle responsive sizes
  const getModifiedImageUrl = (uuid: string, width?: number): string => {
    // If specific width is provided, use that (for high-res preview)
    // Otherwise calculate optimal size based on container
    const containerWidth = carouselContainerRef.current?.clientWidth || 1200;
    const columns = getVisibleItems(window.innerWidth);
    
    // Calculate optimal size if width not specified
    const calculatedWidth = width || calculateOptimalImageSize(
      // For gallery items, divide container by number of columns
      // Add 20% for hover scaling effect
      Math.ceil(containerWidth / columns * 1.2)
    );
    
    // Build URL with calculated or specified width
    const baseUrl = `https://assets.barq.app/image/${uuid}.jpeg?width=${calculatedWidth}`;
    
    // Add cache busting parameter if necessary
    if (imageCacheBuster) {
      return `${baseUrl}&t=${imageCacheBuster}`;
    }
    return baseUrl;
  };
  
  // Function to clear cookies for debugging
  const clearCookies = () => {
    try {
      // Get all cookies
      const cookies = document.cookie.split(";");
      
      // Delete each cookie
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i];
        const eqPos = cookie.indexOf("=");
        const name = eqPos > -1 ? cookie.substring(0, eqPos).trim() : cookie.trim();
        document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/";
      }
      
      // Also try to clear localStorage and sessionStorage
      localStorage.clear();
      sessionStorage.clear();
      
      // Log for debugging
      console.log('Cookies and storage cleared', new Date().toISOString());
      
      // Alert user
      alert('Cookies and local storage cleared successfully');
    } catch (err) {
      // Type assertion to handle the unknown error type
      const error = err as Error;
      console.error('Error clearing cookies:', error);
      alert('Error clearing cookies: ' + (error.message || 'Unknown error'));
    }
  };

  // Track container sizes for responsive image loading
  const [containerSizes, setContainerSizes] = useState({
    gallery: 0,
    carousel: 0
  });

  // Update container sizes on window resize
  useEffect(() => {
    const updateContainerSizes = () => {
      // Get gallery container size
      const galleryContainer = document.querySelector('.gallery-grid');
      const galleryItemWidth = galleryContainer ? 
        galleryContainer.clientWidth / getVisibleItems(window.innerWidth) : 0;
      
      setContainerSizes({
        gallery: galleryItemWidth,
        carousel: carouselContainerRef.current?.clientWidth || 0
      });
    };
    
    // Initial calculation
    updateContainerSizes();
    
    // Update on resize
    window.addEventListener('resize', updateContainerSizes);
    return () => window.removeEventListener('resize', updateContainerSizes);
  }, []);

  // Function to get optimal image size for gallery items
  const getGalleryImageSize = (index: number): number => {
    // Use container size with device pixel ratio
    const dpr = window.devicePixelRatio || 1;
    const columns = getVisibleItems(window.innerWidth);
    const baseSize = containerSizes.gallery || (window.innerWidth / columns);
    
    // Round to nearest 50px and apply bounds
    return calculateOptimalImageSize(baseSize, dpr);
  };

  // When high-res image is loaded, add "loaded" class to the thumbnail
  useEffect(() => {
    // Apply "loaded" class to thumbnails of images that have full-res versions loaded
    const applyLoadedClass = () => {
      // Find all thumbnails and check if they have full-res versions loaded
      fullResLoadedImages.current.forEach(uuid => {
        // Find gallery items with this uuid
        document.querySelectorAll(`img[src*="${uuid}"]`).forEach(element => {
          // Add a class to the parent element to mark it as loaded
          const parentElement = element.closest('div');
          if (parentElement) {
            parentElement.classList.add('thumbnail-loaded');
          }
        });
      });
    };
    
    // Apply loaded class when the component mounts and whenever the fullResLoadedImages set changes
    applyLoadedClass();
    
    // Listen for cache updates and update classes
    const updateInterval = setInterval(applyLoadedClass, 5000);
    
    return () => {
      clearInterval(updateInterval);
    };
  }, [galleryKey, imageCacheBuster]); // Re-run when gallery is refreshed or cache is busted

  return (
    <div className="min-h-screen bg-secondary text-white">
      {/* Banner Image - Fixed at top with parallax effect */}
      <div className="fixed top-0 left-0 right-0 h-[50vh] z-0 overflow-hidden">
        <div
          style={{
            backgroundImage: `url('/img/banner.JPEG')`,
            backgroundSize: 'cover',
            backgroundPosition: 'center 30%',
            height: 'calc(100% + 100px)',
            width: '100%',
            transform: `translate3d(0, ${-50 + scrollY * -0.2}px, 0)`,
            willChange: 'transform',
            transition: 'transform 0.05s cubic-bezier(0.33, 1, 0.68, 1)'
          }}
        ></div>
        </div>
        
      {/* Gradient Overlay - Fixed with banner */}
      <div className="fixed top-0 left-0 right-0 h-[50vh] bg-gradient-to-b from-transparent to-secondary z-0 opacity-80"></div>
      
      {/* Scrollable Content Area */}
      <div className="relative z-10">
        {/* Empty space to push content below the banner */}
        <div className="h-[30vh]"></div>
        
        {/* Main Content with dark background */}
        <div className="bg-secondary min-h-[70vh] rounded-t-3xl shadow-lg pt-10">
          <div className="container mx-auto px-4">
            {/* Profile Header */}
            <div className="flex flex-col sm:flex-row items-center sm:items-end gap-6 mb-8">
              <div className="relative -mt-28 sm:-mt-32 lg:-mt-36">
                <img
                  src={getModifiedImageUrl(profile.profileImage.image.uuid)}
                  alt={profile.displayName}
                  className="w-32 h-32 sm:w-40 sm:h-40 lg:w-48 lg:h-48 rounded-2xl lg:rounded-3xl object-cover border-4 border-[rgb(255,138,128)] shadow-xl"
                />
                {isVip && (
                  <div className="absolute -top-2 -right-2 bg-[rgb(255,138,128)] text-white p-1 rounded-full">
                    <StarIcon className="w-5 h-5" />
                  </div>
                )}
              </div>
              <div className="flex-1 pb-4 text-center sm:text-left">
                <h1 className="text-3xl lg:text-5xl font-bold mb-2 mt-4 sm:mt-0 text-white">{profile.displayName}</h1>
                <div className="flex flex-wrap gap-4 text-gray-200 max-w-5xl">
                  <div className="flex items-center gap-2">
                    <MapPinIcon className="w-5 h-5 text-[rgb(255,138,128)]" />
                    <span>{profile.location.place.place}, {profile.location.place.country}</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <CakeIcon className="w-5 h-5 text-[rgb(255,138,128)]" />
                    <span>{profile.age} years old</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <UserIcon className="w-5 h-5 text-[rgb(255,138,128)]" />
                    <span>He/Him</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <HeartIcon className="w-5 h-5 text-[rgb(255,138,128)]" />
                    <span>Gay</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <HeartIconSolid className="w-5 h-5 text-[rgb(255,138,128)]" />
                    <span>Dating</span>
                  </div>
                </div>
              </div>
            </div>

            {/* Image Carousel */}
            <div className="carousel-container relative z-20" ref={carouselContainerRef}>
              <button 
                onClick={handlePrev}
                    className="carousel-button prev z-30"
                disabled={isAnimating}
                aria-label="Previous image"
                    style={{ left: 0, position: 'absolute', top: '50%', transform: 'translateY(-50%)' }}
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                </svg>
              </button>
              <div 
                className="carousel-track"
                style={{ 
                  transform: `translateX(-${currentIndex * (itemWidth + 8)}px)`,
                  width: 'max-content',
                  paddingLeft: '0.25rem',
                  paddingRight: '0.25rem'
                }}
              >
                    {extendedImages.map((image, index) => {
                      // Check if full-res is loaded for this image
                      const isLoaded = fullResLoadedImages.current.has(image.image.uuid);
                      
                      return (
                <div
                  key={`${image.id}-${index}`}
                        className={`carousel-item relative z-20 cursor-pointer overflow-hidden ${isLoaded ? 'thumbnail-loaded' : ''}`}
                onClick={() => !isAnimating && handleImageClick(image, index)}
                        ref={el => imageRefs.current[`image-${index}`] = el}
                style={{ 
                  width: `${itemWidth}px`,
                  flexBasis: `${itemWidth}px`
                }}
              >
                <img
                        src={getModifiedImageUrl(image.image.uuid)}
                  alt={`${profile.displayName}'s photo ${index + 1}`}
                  loading="lazy"
                  draggable="false"
                        className="w-full h-full object-cover pointer-events-auto transition-transform duration-300 hover:scale-110"
                />
              </div>
                    );
                  })}
              </div>
              <button 
                onClick={handleNext}
                    className="carousel-button next z-30"
                disabled={isAnimating}
                aria-label="Next image"
                    style={{ right: 0, position: 'absolute', top: '50%', transform: 'translateY(-50%)' }}
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
              </button>
          </div>

          {/* Main Content */}
                <div className="mt-8">
              <div className="grid lg:grid-cols-12 gap-8">
                {/* Left Column */}
                <div className="lg:col-span-3">
                  {/* About Section */}
                  <div className="section-card">
                    <h2 className="section-title">About</h2>
                    <div className="space-y-3">
                      {mainInfo.map((info) => (
                        <div key={info.id} className="flex-center gap-small">
                          <info.icon className="icon-small icon-accent" />
                          <span className="section-text">{info.title}</span>
                        </div>
                      ))}
                    </div>
                  </div>

                  {/* Stats Section */}
                  <div className="section-card">
                    <h2 className="section-title">Stats</h2>
                    <div className="space-y-4">
                      {statsInfo.map((section) => (
                        <div key={section.category}>
                          <h3 className="text-sm font-semibold icon-accent mb-2">{section.category}</h3>
                          <div className="space-y-2">
                            {section.items.map((item) => (
                              <div key={item.id} className="flex-center gap-small">
                                <item.icon className="icon-small icon-accent" />
                                <span className="section-text">{item.title}</span>
                              </div>
                            ))}
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>

                  {/* Tech Setup */}
                  <div className="section-card">
                    <h2 className="section-title">Tech Setup</h2>
                    <div className="space-y-4">
                      {Object.entries(techSetup).map(([category, items]) => (
                        <div key={category}>
                          <h3 className="text-sm font-semibold icon-accent mb-2">{category}</h3>
                          <div className="space-y-2">
                            {items.map((item) => (
                              <div key={item.id} className="flex-center gap-small">
                                <item.icon className="icon-small icon-accent" />
                                <span className="section-text">{item.title}</span>
                              </div>
                            ))}
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>

                  {/* Platforms */}
                  <div className="section-card">
                    <h2 className="section-title">Platforms</h2>
                    <div className="space-y-2">
                      {platforms.map((platform) => (
                        <div key={platform.id} className="flex-center gap-small">
                          <FontAwesomeIcon icon={platform.icon} className="icon-small icon-accent" />
                          <span className="section-text">{platform.title}</span>
                        </div>
                      ))}
                    </div>
                  </div>

                  {/* Social Links */}
                  <div className="section-card">
                    <h2 className="section-title">Social Links</h2>
                    <div className="space-y-3">
                      {publicSocialAccounts.map((account) => {
                        let icon;
                        switch (account.socialNetwork.toLowerCase()) {
                          case 'twitter':
                            icon = faTwitter;
                            break;
                          case 'instagram':
                            icon = faInstagram;
                            break;
                          case 'discord':
                            icon = faDiscord;
                            break;
                          case 'steam':
                            icon = faSteam;
                            break;
                          default:
                            icon = GlobeAltIcon;
                        }

                        return (
                          <a
                            key={account.id}
                            href={account.url}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="social-link"
                          >
                            <div className="social-icon-container section-card">
                              {typeof icon === 'function' ? (
                                React.createElement(icon, { className: "icon-small" })
                              ) : (
                                <FontAwesomeIcon icon={icon} className="icon-small" />
                              )}
                            </div>
                            <div className="flex-1">
                              <div className="flex-center gap-small">
                                <span className="section-text">{account.displayName}</span>
                                {account.isVerified && (
                                  <CheckBadgeIcon className="icon-small icon-accent" />
                                )}
                              </div>
                              <span className="text-xs text-gray-400">{account.value}</span>
                            </div>
                            <ArrowTopRightOnSquareIcon className="icon-small icon-accent" />
                          </a>
                        );
                      })}
                    </div>
                  </div>
                </div>

                {/* Right Column - Photo Grid */}
                <div className="lg:col-span-9">
                        <div key={galleryKey} className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 gallery-grid">
                          {publicImages.map((photo, index) => {
                            // Calculate optimal image size for this grid item
                            const optimalSize = getGalleryImageSize(index);
                            
                            // Check if full-res is loaded for this image
                            const isLoaded = fullResLoadedImages.current.has(photo.image.uuid);
                            
                            return (
                      <div
                                key={photo.id + (imageCacheBuster || '')}
                        ref={el => imageRefs.current[`image-${index}`] = el}
                                className={`aspect-square rounded-xl overflow-hidden cursor-pointer transform hover:scale-105 transition duration-300 ring-1 ring-[rgb(255,138,128)]/10 hover:ring-[rgb(255,138,128)]/30 ${isLoaded ? 'thumbnail-loaded' : ''}`}
                        onClick={() => handleImageClick(photo, index)}
                      >
                        <img
                                  src={getModifiedImageUrl(photo.image.uuid, optimalSize)}
                          alt={`${profile.displayName}'s photo ${index + 1}`}
                                  className="w-full h-full object-cover transition-transform duration-500 hover:scale-110"
                                  loading="lazy"
                                  key={imageCacheBuster || undefined}
                        />
                      </div>
                            );
                          })}
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            {/* Image Preview Modal */}
            {selectedImage && startPosition && (
              <div
                className={`fixed inset-0 z-50 ${isAnimating ? 'bg-black/90' : 'bg-transparent'} transition-all duration-300 ease-out`}
                onClick={handleClosePreview}
                style={{ 
                  pointerEvents: isAnimating ? 'auto' : 'none',
                  visibility: isAnimating ? 'visible' : 'hidden'
                }}
              >
                <button
                  className={`absolute top-4 right-4 text-white hover:text-gray-300 transition-opacity duration-300 z-[60] ${isAnimating ? 'opacity-100' : 'opacity-0'}`}
                  onClick={(e) => handleClosePreview(e)}
                  style={{ pointerEvents: 'auto' }}
                >
                  <XMarkIcon className="w-8 h-8" />
                </button>
                
                {/* Loading indicator */}
                {isAnimating && !imageLoaded && showLoadingBar && (
                  <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-40 opacity-80">
                    <svg className="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                  </div>
                )}
                
                {/* Progress Bar */}
                {isAnimating && showLoadingBar && (
                  <div className="absolute bottom-8 left-1/2 transform -translate-x-1/2 w-48 md:w-64 z-50">
                    <div className="bg-black/30 backdrop-blur-sm p-3 rounded-lg">
                      <div className="h-1.5 w-full bg-gray-700 rounded-full overflow-hidden">
                        <div 
                          className="h-full bg-gradient-to-r from-[rgb(255,138,128)] to-white rounded-full transition-all duration-200 ease-out"
                          style={{ width: `${loadingProgress}%` }}
                        ></div>
                      </div>
                      <div className="text-center text-white/80 text-xs mt-2 font-medium">
                        {loadingProgress < 100 
                          ? `Loading image... ${Math.round(loadingProgress)}%` 
                          : 'Rendering image...'}
                      </div>
                    </div>
                  </div>
                )}
                
                <div
                  className={`fixed will-change-transform ${springAnimation ? 'transition-all duration-700 ease-[cubic-bezier(0.34,1.56,0.64,1)]' : 'transition-all duration-600 ease-out'}`}
                  style={{
                    width: isAnimating ? calculateExpandedDimensions()?.width : startPosition.width,
                    height: isAnimating ? calculateExpandedDimensions()?.height : startPosition.height,
                    transform: isAnimating
                      ? `translate3d(${calculateExpandedDimensions()?.x}px, ${calculateExpandedDimensions()?.y}px, 0) ${springAnimation ? 'scale(1.02)' : 'scale(1)'}`
                      : `translate3d(${startPosition.x}px, ${startPosition.y}px, 0)`,
                    transformOrigin: 'center',
                    boxShadow: isAnimating ? '0 25px 50px -12px rgba(0, 0, 0, 0.5)' : 'none',
                    overflow: 'hidden',
                    borderRadius: '0.75rem',
                    backgroundColor: 'rgba(0,0,0,0.2)',
                    zIndex: isAnimating ? 55 : 1,
                    transition: isAnimating ? undefined : 'all 250ms cubic-bezier(0.4, 0, 0.2, 1), opacity 200ms ease-out, transform 250ms cubic-bezier(0.4, 0, 0.2, 1)',
                  }}
                >
                  {/* Simplified container structure */}
                  <div className="absolute inset-0 rounded-xl overflow-hidden">
                    {/* Single content container */}
                    <div className="relative w-full h-full">
                      {/* Thumbnail background with blend mode */}
                      <div
                        className={`absolute inset-0 rounded-xl overflow-hidden ${springAnimation ? 'transition-opacity duration-700 ease-in-out' : 'transition-opacity duration-200 ease-out'}`}
                        style={{
                          backgroundImage: `url(${thumbnailUrl.current})`,
                          backgroundSize: 'cover',
                          backgroundPosition: 'center',
                          backgroundRepeat: 'no-repeat',
                          opacity: showHighRes && imageLoaded ? 0 : 0.9,
                          filter: 'blur(0px)',
                          transform: 'scale(1.01)', // Slightly larger to avoid corner gaps
                        }}
                      />
                      
                      {/* High-res image container - only render when needed */}
                      {(showHighRes || imageLoaded) && (
                        <div
                          className={`absolute inset-0 rounded-xl overflow-hidden ${springAnimation ? 'transition-opacity duration-700 ease-in-out' : 'transition-opacity duration-200 ease-out'}`}
                          style={{
                            opacity: showHighRes && imageLoaded ? 1 : 0,
                            backgroundColor: 'rgba(0,0,0,0.15)',
                          }}
                        >
                          {/* Actual high-res image - only render when needed */}
                          {showHighRes && (
                            <img
                              src={getModifiedImageUrl(selectedImage.image.uuid, 1500)}
                              alt="Full resolution preview"
                              className="w-full h-full object-contain"
                              onLoad={handleHighResImageLoad}
                    loading="eager"
                  />
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* Debug buttons */}
            <div className="fixed bottom-4 right-4 z-50 flex flex-col gap-2">
              <button
                onClick={clearCache}
                className="bg-black/30 hover:bg-black/50 text-white/70 hover:text-white text-xs py-2 px-3 rounded-lg backdrop-blur-sm border border-white/10 transition-all duration-200 flex items-center gap-1"
                title="Clear cache (debug)"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clipRule="evenodd" />
                </svg>
                Clear Cache
              </button>
              
              <button
                onClick={clearCookies}
                className="bg-black/30 hover:bg-black/50 text-white/70 hover:text-white text-xs py-2 px-3 rounded-lg backdrop-blur-sm border border-white/10 transition-all duration-200 flex items-center gap-1"
                title="Clear cookies & storage (debug)"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3" viewBox="0 0 20 20" fill="currentColor">
                  <path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2V7a5 5 0 00-5-5zm-4.5 7a.5.5 0 00-.5.5v1a.5.5 0 00.5.5h9a.5.5 0 00.5-.5v-1a.5.5 0 00-.5-.5h-9z" />
                </svg>
                Clear Cookies
              </button>
            </div>
          </div>
        </div>
      );
    };

    export default Profile; 